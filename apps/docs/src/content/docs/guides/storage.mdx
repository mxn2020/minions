---
title: Storage Adapters
description: Persist minions to memory, local JSON files, or custom backends using the pluggable StorageAdapter system.
---

import { Tabs, TabItem } from '@astrojs/starlight/components';

The Minions SDK includes a **pluggable storage abstraction layer** that lets you persist minions to virtually any backend. By default, the SDK operates entirely in-memory, but you can plug in a `StorageAdapter` to write to disk, a database, or a cloud service.

## Quick Start

The simplest way to use storage is through the `Minions` client:

<Tabs syncKey="lang">
<TabItem label="TypeScript">

```typescript
import { Minions, JsonFileStorageAdapter } from 'minions-sdk';

const storage = await JsonFileStorageAdapter.create('./data/minions');
const minions = new Minions({ storage });

// Create and persist a minion
const note = await minions.create('note', { title: 'Hello', fields: { content: 'World' } });
await minions.save(note.data);

// Load it back
const loaded = await minions.load(note.data.id);
console.log(loaded?.title); // > "Hello"
```

</TabItem>
<TabItem label="Python">

```python
from minions import Minions, JsonFileStorageAdapter

storage = await JsonFileStorageAdapter.create("./data/minions")
minions = Minions(storage=storage)

# Create and persist a minion
note = await minions.create("note", {"title": "Hello", "fields": {"content": "World"}})
await minions.save(note.data)

# Load it back
loaded = await minions.load(note.data.id)
print(loaded.title)  # > "Hello"
```

</TabItem>
</Tabs>

---

## Built-In Adapters

### MemoryStorageAdapter

Stores all data in a runtime `Map` (TypeScript) or `dict` (Python). Data is lost when the process exits. Ideal for **tests** and ephemeral scripts.

<Tabs syncKey="lang">
<TabItem label="TypeScript">

```typescript
import { Minions, MemoryStorageAdapter } from 'minions-sdk';

const storage = new MemoryStorageAdapter();
const minions = new Minions({ storage });
```

</TabItem>
<TabItem label="Python">

```python
from minions import Minions, MemoryStorageAdapter

storage = MemoryStorageAdapter()
minions = Minions(storage=storage)
```

</TabItem>
</Tabs>

### JsonFileStorageAdapter

Persists each minion as a **pretty-printed JSON file** in a sharded directory layout:

```
<rootDir>/<id[0:2]>/<id[2:4]>/<id>.json
```

The two-level shard prefix keeps directories small even with millions of minions. An in-memory index is built on startup for O(1) lookups.

- ✅ Writes are **atomic** (write-to-tmp-then-rename) — safe against crashes
- ✅ Files are human-readable and git-friendly
- ⚠️ Server-side / CLI only (uses `node:fs`)

<Tabs syncKey="lang">
<TabItem label="TypeScript">

```typescript
import { Minions, JsonFileStorageAdapter } from 'minions-sdk';

const storage = await JsonFileStorageAdapter.create('./data/minions');
const minions = new Minions({ storage });
```

</TabItem>
<TabItem label="Python">

```python
from minions import Minions, JsonFileStorageAdapter

storage = await JsonFileStorageAdapter.create("./data/minions")
minions = Minions(storage=storage)
```

</TabItem>
</Tabs>

> [!NOTE]
> Use the async factory method `create()` — the constructor is private (TS) or should not be called directly. `create()` ensures the directory exists and the in-memory index is populated.

---

## Client Storage Methods

When a storage adapter is configured on the `Minions` client, these methods become available:

| Method | Description |
|--------|-------------|
| `save(minion)` | Persist a minion (upsert) |
| `load(id)` | Load a minion by ID (returns `undefined`/`None` if not found) |
| `remove(minion)` | Delete from storage and remove all relations |
| `listMinions(filter?)` | List minions with optional filtering |
| `searchMinions(query)` | Full-text search across minions |

All methods throw if no storage adapter is configured.

---

## Filtering and Sorting

The `listMinions()` method accepts a `StorageFilter` to control the result set:

<Tabs syncKey="lang">
<TabItem label="TypeScript">

```typescript
const results = await minions.listMinions({
  minionTypeId: 'note',         // Only notes
  status: 'active',             // Only active
  tags: ['ai', 'research'],     // Must have all tags
  includeDeleted: false,        // Exclude soft-deleted (default)
  sortBy: 'title',              // Sort by 'title', 'createdAt', or 'updatedAt'
  sortOrder: 'asc',             // 'asc' or 'desc'
  limit: 10,                    // Page size
  offset: 0,                    // Skip N results
});
```

</TabItem>
<TabItem label="Python">

```python
from minions import StorageFilter

results = await minions.list_minions(StorageFilter(
    minion_type_id="note",         # Only notes
    status="active",               # Only active
    tags=["ai", "research"],       # Must have all tags
    include_deleted=False,         # Exclude soft-deleted (default)
    sort_by="title",               # Sort by 'title', 'createdAt', or 'updatedAt'
    sort_order="asc",              # 'asc' or 'desc'
    limit=10,                      # Page size
    offset=0,                      # Skip N results
))
```

</TabItem>
</Tabs>

---

## Full-Text Search

The `searchMinions()` method performs case-insensitive, multi-token search against the pre-computed `searchableText` field (built from the minion's title, description, and string fields):

<Tabs syncKey="lang">
<TabItem label="TypeScript">

```typescript
// Find minions mentioning both "quantum" and "computing"
const results = await minions.searchMinions('quantum computing');
```

</TabItem>
<TabItem label="Python">

```python
# Find minions mentioning both "quantum" and "computing"
results = await minions.search_minions("quantum computing")
```

</TabItem>
</Tabs>

> [!TIP]
> Search automatically excludes soft-deleted minions. An empty query returns all non-deleted minions.

---

## Storage Hooks (`withHooks`)

Wrap any `StorageAdapter` with before/after hooks for cross-cutting storage concerns like logging, encryption, or metrics — without changing the `Minions` client configuration.

<Tabs syncKey="lang">
<TabItem label="TypeScript">

```typescript
import { withHooks, MemoryStorageAdapter, Minions } from 'minions-sdk';

const storage = withHooks(new MemoryStorageAdapter(), {
  beforeSet: async (minion) => {
    // Transform data before writing
    return { ...minion, fields: { ...minion.fields, savedAt: new Date().toISOString() } };
  },
  afterGet: async (id, result) => {
    if (result) console.log('Loaded:', result.title);
  },
});

const minions = new Minions({ storage });
```

</TabItem>
<TabItem label="Python">

```python
from minions import Minions, MemoryStorageAdapter
from minions.storage import with_hooks, StorageHooks

async def stamp_save(minion):
    import dataclasses
    return dataclasses.replace(minion, fields={**minion.fields, "saved_at": "now"})

async def log_load(id, result):
    if result:
        print("Loaded:", result.title)

storage = with_hooks(MemoryStorageAdapter(), StorageHooks(
    before_set=stamp_save,
    after_get=log_load,
))

minions = Minions(storage=storage)
```

</TabItem>
</Tabs>

Available hooks: `beforeGet`, `afterGet`, `beforeSet` (can transform), `afterSet`, `beforeDelete`, `afterDelete`, `beforeList`, `afterList`, `beforeSearch`, `afterSearch`.

> [!TIP]
> See the [Middleware & Hooks guide](/guides/middleware/) for the full reference and comparison with the client-level middleware pipeline.

---

## Custom Adapters

To connect Minions to a different backend (PostgreSQL, MongoDB, Redis, Supabase, etc.), implement the `StorageAdapter` interface:

<Tabs syncKey="lang">
<TabItem label="TypeScript">

```typescript
import type { StorageAdapter, StorageFilter } from 'minions-sdk';
import type { Minion } from 'minions-sdk';

export class PostgresStorageAdapter implements StorageAdapter {
  async get(id: string): Promise<Minion | undefined> { /* ... */ }
  async set(minion: Minion): Promise<void> { /* ... */ }
  async delete(id: string): Promise<void> { /* ... */ }
  async list(filter?: StorageFilter): Promise<Minion[]> { /* ... */ }
  async search(query: string): Promise<Minion[]> { /* ... */ }
}

// Use it like any other adapter:
const storage = new PostgresStorageAdapter(/* connection config */);
const minions = new Minions({ storage });
```

</TabItem>
<TabItem label="Python">

```python
from minions.storage import StorageAdapter, StorageFilter
from minions.types import Minion
from typing import Optional

class PostgresStorageAdapter(StorageAdapter):
    async def get(self, id: str) -> Optional[Minion]: ...
    async def set(self, minion: Minion) -> None: ...
    async def delete(self, id: str) -> None: ...
    async def list(self, filter: Optional[StorageFilter] = None) -> list[Minion]: ...
    async def search(self, query: str) -> list[Minion]: ...

# Use it like any other adapter:
storage = PostgresStorageAdapter(# connection config)
minions = Minions(storage=storage)
```

</TabItem>
</Tabs>

### Methods to Implement

| Method | Signature | Behavior |
|--------|-----------|----------|
| `get` | `(id) → Minion?` | Return `undefined`/`None` if not found |
| `set` | `(minion) → void` | Upsert — insert or overwrite |
| `delete` | `(id) → void` | Resolve silently if missing |
| `list` | `(filter?) → Minion[]` | Apply filtering, sorting, pagination |
| `search` | `(query) → Minion[]` | Case-insensitive token matching |

> [!TIP]
> Use the shared `applyFilter()` utility (exported from `minions-sdk`) to handle `StorageFilter` logic in your custom adapter — no need to reimplement filtering/sorting.
