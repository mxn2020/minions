# Minions Specification v0.1

## 1. Introduction

**Minions** is a universal structured object system designed primarily for defining, organizing, and running AI agents, but flexible enough to model anything.

AI agents need a structured home — a format that is queryable, nestable, evolvable, and AI-readable. Current tools are either too rigid (fixed schemas that break under change) or too loose (freeform JSON with no validation). Minions fills this gap with a system built on three simple primitives that compose into arbitrarily complex structures.

The primary use case is AI agents. An agent can start as a single flat minion and grow into a nested tree of minions covering every aspect of its definition, memory, and behavior. The system is self-referential by design: agents can use minions to store their own thoughts, tasks, and decisions.

## 2. Goals

1. **Progressive complexity** — start with a single flat minion, grow into nested structures without migration pain
2. **Framework agnostic** — the spec and core library work regardless of storage backend or runtime
3. **AI-friendly** — structured, queryable, nestable objects that agents can read and write reliably
4. **Self-referential** — the system can describe itself using itself
5. **Composable** — any minion can relate to any other minion with typed relations
6. **Schema-driven** — all fields are defined by JSON Schema, all types are validated

## 3. Glossary

| Term | Definition |
|------|-----------|
| **Minion** | A structured object instance — the fundamental unit of the system |
| **MinionType** | The schema/definition that describes a kind of minion |
| **Relation** | A typed, directional link between two minions |
| **Field** | A single data property defined by a FieldDefinition within a MinionType schema |
| **FieldDefinition** | The schema for a field: name, type, constraints, default value |
| **Schema** | An array of FieldDefinitions that defines what fields a minion of a given type has |
| **Layer** | A conceptual grouping of MinionTypes by purpose (Definition, Organization, Memory, Interface, Evaluation, Execution) |
| **Slug** | A URL-safe, kebab-case identifier unique within the system |
| **Lifecycle** | The states a minion passes through: creation, update, soft delete, restore, hard delete |

## 4. Core Primitives

### 4.1 Minion

A Minion is a structured object instance. Every minion is an instance of exactly one MinionType.

**Required fields:**

| Field | Type | Description |
|-------|------|-------------|
| `id` | string (UUID v4) | Unique identifier |
| `title` | string | Human-readable title |
| `minionTypeId` | string | Reference to the MinionType |
| `fields` | Record<string, any> | Dynamic field values defined by the type schema |
| `createdAt` | string (ISO 8601) | Creation timestamp |
| `updatedAt` | string (ISO 8601) | Last update timestamp |

**Optional fields:**

| Field | Type | Description |
|-------|------|-------------|
| `tags` | string[] | Freeform tags |
| `status` | enum | One of: `active`, `todo`, `in_progress`, `completed`, `cancelled` |
| `priority` | enum | One of: `low`, `medium`, `high`, `urgent` |
| `description` | string | Longer description |
| `dueDate` | string (ISO 8601) | Due date |
| `categoryId` | string | Reference to a category |
| `folderId` | string | Reference to a folder |
| `createdBy` | string | Creator identifier |
| `updatedBy` | string | Last updater identifier |
| `deletedAt` | string (ISO 8601) or null | Soft delete timestamp |
| `deletedBy` | string or null | Who deleted it |
| `searchableText` | string | Computed full-text search field |
| `_legacy` | Record<string, any> | Legacy field values preserved after schema evolution |

### 4.2 MinionType

A MinionType defines the schema and behavior of a kind of minion.

**Required fields:**

| Field | Type | Description |
|-------|------|-------------|
| `id` | string (UUID v4) | Unique identifier |
| `name` | string | Human-readable name |
| `slug` | string | URL-safe kebab-case identifier, unique within the system |
| `schema` | FieldDefinition[] | Array of field definitions |

**Optional fields:**

| Field | Type | Description |
|-------|------|-------------|
| `description` | string | Purpose of this type |
| `icon` | string | Emoji or icon name |
| `color` | string | Hex color code |
| `isSystem` | boolean | Whether this is a built-in type (default: false) |
| `isOrganizational` | boolean | Whether this is a container type (default: false) |
| `allowedChildTypes` | string[] | Type IDs allowed as children |
| `behaviors` | string[] | Behavior flags (e.g. "executable") |
| `defaultView` | string | Default view mode |
| `availableViews` | string[] | Available view modes |
| `createdAt` | string (ISO 8601) | Creation timestamp |
| `updatedAt` | string (ISO 8601) | Last update timestamp |

### 4.3 Relation

A Relation is a typed, directional link between two minions.

**Required fields:**

| Field | Type | Description |
|-------|------|-------------|
| `id` | string (UUID v4) | Unique identifier |
| `sourceId` | string | Source minion ID |
| `targetId` | string | Target minion ID |
| `type` | RelationType | Semantic type of the relation |
| `createdAt` | string (ISO 8601) | Creation timestamp |

**Optional fields:**

| Field | Type | Description |
|-------|------|-------------|
| `metadata` | any | Arbitrary metadata |
| `createdBy` | string | Creator identifier |

## 5. Field Type System

### 5.1 Supported Types

| Type | JSON Schema Mapping | Description |
|------|-------------------|-------------|
| `string` | `{ "type": "string" }` | Short text value |
| `number` | `{ "type": "number" }` | Numeric value |
| `boolean` | `{ "type": "boolean" }` | True/false |
| `date` | `{ "type": "string", "format": "date-time" }` | ISO 8601 date string |
| `select` | `{ "type": "string", "enum": [...] }` | Single selection from options |
| `multi-select` | `{ "type": "array", "items": { "enum": [...] } }` | Multiple selections |
| `url` | `{ "type": "string", "format": "uri" }` | HTTP/HTTPS URL |
| `email` | `{ "type": "string", "format": "email" }` | Email address |
| `textarea` | `{ "type": "string" }` | Long-form text |
| `tags` | `{ "type": "array", "items": { "type": "string" } }` | Array of string tags |
| `json` | `{}` | Free-form JSON value |
| `array` | `{ "type": "array" }` | Generic array |

### 5.2 FieldDefinition Structure

```typescript
interface FieldDefinition {
  name: string;        // Field key (required)
  type: FieldType;     // One of the types above (required)
  label?: string;      // Display label
  description?: string; // Field description
  required?: boolean;  // Default: false
  defaultValue?: any;  // Default value
  options?: string[];  // For select/multi-select
  validation?: {       // Additional constraints
    minLength?: number;
    maxLength?: number;
    min?: number;
    max?: number;
    pattern?: string;  // Regex pattern
  };
}
```

### 5.3 Validation Rules

1. If `required` is true and the value is `undefined`, `null`, or empty string `""`, validation MUST fail.
2. If the value is absent and `required` is false, no further validation is performed.
3. Type-specific validation:
   - `string`/`textarea`: value MUST be typeof string. `minLength`, `maxLength`, `pattern` constraints apply.
   - `number`: value MUST be typeof number and not NaN. `min`, `max` constraints apply.
   - `boolean`: value MUST be typeof boolean.
   - `date`: value MUST be a valid ISO 8601 date string (e.g. `"2024-01-15"` or `"2024-01-15T10:30:00Z"`).
   - `select`: value MUST be a string present in `options`.
   - `multi-select`: value MUST be an array where every element is in `options`.
   - `url`: value MUST be a string matching `^https?://`.
   - `email`: value MUST be a string matching a basic email pattern.
   - `tags`: value MUST be an array of strings.
   - `json`: any valid JSON value is accepted.
   - `array`: value MUST be an array.

## 6. Relation Type System

### 6.1 Supported Relation Types

| Type | Semantics | Example |
|------|----------|---------|
| `parent_of` | Hierarchical parent → child | Agent → Skill |
| `depends_on` | Source depends on target | Task → Task |
| `implements` | Source implements target spec | Agent → API Contract |
| `relates_to` | Generic association | Note → Note |
| `inspired_by` | Source inspired by target | Agent → Agent |
| `triggers` | Activating source triggers target | Trigger → Action |
| `references` | Source references target as context | Thought → Document |
| `blocks` | Source blocks progress on target | Bug → Feature |
| `alternative_to` | Source is alternative to target | Agent A → Agent B |
| `part_of` | Source is a component of target | Skill → Agent |
| `follows` | Source follows target in sequence | Step 2 → Step 1 |
| `integration_link` | Source linked to external integration | Minion → External |

### 6.2 Cardinality

All relations are **many-to-many**. A minion can have any number of relations of any type.

### 6.3 Self-Referencing Relations

A relation where `sourceId === targetId` is **explicitly permitted**. Self-referencing relations are useful for reflexive semantics such as:

- A minion that references an earlier version of itself (`relates_to`)
- A thought that is inspired by itself (`inspired_by`)
- A recursive task that triggers itself (`triggers`)

Implementations MUST NOT reject or error on self-referencing relations. Whether to display or traverse them is an application-level concern.

### 6.4 Cascading Behavior

- On **soft delete**: relations are preserved but the deleted minion should be excluded from standard queries.
- On **hard delete**: all relations where the deleted minion is source OR target MUST be removed. Target minions are NOT deleted.

## 7. Standard Layer Types

Each layer is a conceptual grouping. The types within each layer are standard MinionTypes.

### 7.1 Definition Layer

What a thing is — agent identity, skills, tools, personality.

**Agent** (`agent`):

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `role` | string | no | Agent's role |
| `model` | string | no | LLM model identifier |
| `systemPrompt` | textarea | no | System prompt |
| `temperature` | number | no | Sampling temperature (0–2) |
| `maxTokens` | number | no | Maximum token limit |
| `tools` | tags | no | Available tool names |

### 7.2 Organization Layer

How things group and relate — teams, collections, hierarchies.

**Team** (`team`):

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `members` | tags | no | Member identifiers |
| `strategy` | select | no | Options: round_robin, parallel, sequential |
| `maxConcurrency` | number | no | Max parallel execution |

### 7.3 Memory/Observation Layer

What a thing knows or has experienced.

**Thought** (`thought`):

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `content` | textarea | yes | The thought content |
| `confidence` | number | no | Confidence score (0–1) |
| `source` | string | no | Origin of the thought |

### 7.4 Interface/Communication Layer

How a thing presents itself.

**Prompt Template** (`prompt-template`):

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `template` | textarea | yes | Template text with variables |
| `variables` | tags | no | Variable names used in template |
| `outputFormat` | select | no | Options: text, json, markdown |

### 7.5 Evaluation Layer

How a thing is measured.

**Test Case** (`test-case`):

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `input` | json | yes | Test input data |
| `expectedOutput` | json | no | Expected output |
| `assertions` | json | no | Assertion rules |
| `timeout` | number | no | Timeout in milliseconds |

### 7.6 Execution Layer

What a thing does. **Note:** The Execution Layer is defined as an interface only in v0.1. No runtime implementation is specified.

**Task** (`task`):

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `input` | json | no | Task input data |
| `output` | json | no | Task output data |
| `executionStatus` | select | no | Options: pending, running, completed, failed, cancelled |
| `startedAt` | date | no | Execution start time |
| `completedAt` | date | no | Execution end time |
| `error` | textarea | no | Error message if failed |

## 8. Built-in Minion Types

These four types MUST be supported by all conformant implementations:

### 8.1 Note (`note`)

| Field | Type | Required |
|-------|------|----------|
| `content` | textarea | yes |

### 8.2 Link (`link`)

| Field | Type | Required |
|-------|------|----------|
| `url` | url | yes |
| `description` | textarea | no |

### 8.3 File (`file`)

| Field | Type | Required |
|-------|------|----------|
| `filename` | string | yes |
| `fileUrl` | url | yes |
| `fileSize` | number | no |
| `mimeType` | string | no |

### 8.4 Contact (`contact`)

| Field | Type | Required |
|-------|------|----------|
| `name` | string | yes |
| `email` | email | no |
| `phone` | string | no |
| `company` | string | no |
| `notes` | textarea | no |

## 9. Lifecycle Rules

### 9.1 Creation

- `id` MUST be generated as a UUID v4
- `createdAt` MUST be set to the current ISO 8601 timestamp
- `updatedAt` MUST equal `createdAt` on creation
- `fields` MUST be validated against the MinionType schema
- `status` defaults to `"active"` if not specified
- Default values from the schema SHOULD be applied for absent fields

### 9.2 Update

- `updatedAt` MUST be set to the current ISO 8601 timestamp
- `fields` MUST be validated against the current MinionType schema
- Partial updates merge with existing fields

### 9.3 Soft Delete

- Sets `deletedAt` to the current ISO 8601 timestamp
- Sets `deletedBy` if the deleter is known
- The minion MUST NOT appear in standard queries
- Relations MUST be preserved

### 9.4 Restore

- Clears `deletedAt` (sets to null)
- Clears `deletedBy` (sets to null)
- Relations are re-activated

### 9.5 Hard Delete

- Permanently removes the minion from storage
- All relations where this minion is source or target MUST be removed
- Target minions of those relations are NOT deleted

## 10. Schema Evolution Rules

When a MinionType schema changes:

| Change | Behavior |
|--------|----------|
| Field added | Existing minions get the default value or remain without the field |
| Field removed | Existing values are preserved in `_legacy` namespace |
| Field type changed | Values incompatible with the new type move to `_legacy` |
| Field made required | Existing minions missing the field are flagged for migration |
| Validation changed | Existing values are NOT retroactively validated |

**Migration function signature:**

```typescript
function migrateMinion(
  minion: Minion,
  oldSchema: FieldDefinition[],
  newSchema: FieldDefinition[]
): Minion
```

The migration function MUST:
1. Preserve all values that are compatible with the new schema
2. Move incompatible or removed field values to `_legacy`
3. Apply default values for newly added fields
4. Update the `updatedAt` timestamp

### 10.1 Worked Example

An `agent` type schema changes: `temperature` is removed, `maxTokens` type changes from `number` to `string`, and a new field `provider` is added with a default value.

**Before migration:**

```json
{
  "id": "agent-001",
  "title": "Research Assistant",
  "minionTypeId": "builtin-agent",
  "fields": {
    "role": "researcher",
    "model": "gpt-4",
    "temperature": 0.7,
    "maxTokens": 4096
  },
  "createdAt": "2024-01-15T10:00:00Z",
  "updatedAt": "2024-01-15T10:00:00Z"
}
```

**After migration:**

```json
{
  "id": "agent-001",
  "title": "Research Assistant",
  "minionTypeId": "builtin-agent",
  "fields": {
    "role": "researcher",
    "model": "gpt-4",
    "provider": "openai"
  },
  "_legacy": {
    "temperature": 0.7,
    "maxTokens": 4096
  },
  "createdAt": "2024-01-15T10:00:00Z",
  "updatedAt": "2024-06-01T12:00:00Z"
}
```

- `temperature` was removed from the schema → moved to `_legacy`
- `maxTokens` changed from `number` to `string` and `4096` is incompatible → moved to `_legacy`
- `provider` is new with default `"openai"` → applied
- `role` and `model` are unchanged → preserved

## 11. Versioning and Identity

- All IDs are UUID v4 strings
- MinionType slugs are unique within a system
- This specification is version **0.1.0** (semver)
- Types have implicit versioning via `updatedAt`
- Future versions may add explicit schema versioning with migration chains

## 12. Execution Contract

The minimal interface for execution:

```typescript
interface Executable {
  execute(input: Record<string, any>): Promise<ExecutionResult>
}

interface ExecutionResult {
  output: any
  status: 'completed' | 'failed' | 'cancelled'
  startedAt: string   // ISO 8601
  completedAt: string  // ISO 8601
  error?: string
  metadata?: Record<string, any>
}
```

This is an **interface definition only**. Implementations may interpret execution differently based on context. The execution layer is intentionally minimal in v0.1 to avoid over-specifying runtime behavior.

## 13. Conformance Checklist

An implementation is **conformant** with Minions Specification v0.1 if it:

- [ ] 1. Implements all three core primitives (Minion, MinionType, Relation)
- [ ] 2. Supports all 12 field types with proper validation
- [ ] 3. Supports all 12 relation types
- [ ] 4. Implements the complete lifecycle (create, update, soft delete, restore, hard delete)
- [ ] 5. Validates minion fields against their type schema on create and update
- [ ] 6. Supports the four built-in types (note, link, file, contact)
- [ ] 7. Preserves legacy field values on schema evolution
- [ ] 8. Generates valid UUIDs for all IDs
- [ ] 9. Uses ISO 8601 for all timestamps
- [ ] 10. Removes relations on hard delete of a minion
- [ ] 11. Permits self-referencing relations (sourceId === targetId) without error

---

*Minions Specification v0.1.0 — Copyright (C) 2026 Minions Contributors — MIT*
